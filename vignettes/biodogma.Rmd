---
title: "biodogma"
output: rmarkdown::github_document
vignette: >
  %\VignetteIndexEntry{biodogma}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(biodogma)
```

## Description of the package `biodogma`:

The package `biodogma` consists of 5 simple functions that allows us to model the central dogma of molecular biology. This theory was proposed by Francis Crick in 1957 and states that genetic information flows from **DNA** to **RNA** via the process of [transcription]{.underline}, and from RNA to **protein** via [translation]{.underline}. To replicate this, we have created several functions to replicate these processes.

The functions included in the `biodogma` package are:

### **Function 1:** `gen_dna_seq()`

The `gen_dna_seq` function generates a random DNA sequence of a specified length. Each nucleotide in the sequence is chosen randomly from the set {A, T, G, C} to simulate a DNA sequence.

#### **Usage**

`gen_dna_seq(length)`

##### **Arguments**

-   `length`: An integer specifying the desired length of the DNA sequence.
-   A character string representing a randomly generated DNA sequence of the specified length.

#### Example

```{r}
# Load the biodogma package
#library(biodogma)
# Define the desired length for the DNA sequence
length <- 10
# Generate a random DNA sequence of the specified length
dna_seq <- gen_dna_seq(length)
# Print the generated DNA sequence
print(dna_seq)
```

### **Function 2:** `dna_to_rna()`

In the process of transcription, DNA is converted to RNA by replacing each occurrence of thymine (T) with uracil (U), which is specific to RNA.

#### Usage

`dna_to_rna(dna_sequence)`

##### Arguments

-   `dna_sequence`: a character string containing the DNA sequence that needs to be transcribed.

##### Return

-   A character string representing the RNA sequence, with all occurrences of "T" replaced by "U".

```{r}
# Load the biodogma package
#library("biodogma")  
# Define a DNA sequence
dna_sequence <- "ATGCTTAC"
# Transcribe DNA to RNA
rna_sequence <- dna_to_rna(dna_sequence)
# Print the RNA sequence
print(rna_sequence)
```

### **Function 3:** `split_codon()`

mRNA sequences are read in codons or groups of three ribonucleotides, each of these coding for a specific amino acid. The purpose of `split_codon` is to split a string of an RNA sequence into a vector of codons.

#### Usage

`split_codon(rna_seq, starting_codon_position)`

##### Arguments

-   `rna_seq`: a character string containing the RNA sequence.

-   `starting_codon_position`: an int variable providing the position of the initial codon in the given sequence. It's *not necessary* to provide this argument, the default value being position 1.

##### Return

-   A vector containing the codons found in the given string.

```{r}
# Load the biodogma package
#library("biodogma")
# Provide an RNA sequence
rna_seq <- "AUGACUAAGA"
pos <- 2
# Call the function without specifying the starting position
split_codon(rna_seq)
# Call the function specifying the starting position
split_codon(rna_seq, pos)
```

### Function 4: `gen_aa_seq()`

After the mRNA has been synthesized, the molecule leaves the nucleus and is read by ribosomes for generating the resulting protein. In this process, called biological translation, each triplet of ribonucleotides ('codons') result in one specific amino acid, that will generate the amino acid chain. This equivalence happens accordingly to the genetic code.

**Usage**

`gen_aa_seq <- function(codons)`

##### **Arguments**

`codon`: a vector containing the triplets of the considered mRNA chain.

##### **Return**

After calling the function, the user will get a character string with the amino acid chain.

```{r}
#Load the library
#library("biodogma")
#Define a vector with the codons that will be translated into proteins. 
#NOTE: the user may obtain this vector from the function splitcodon(). 
codons <-  c("AUG", "ACU", "AAG") 
#Call the function 
aa_seq <- gen_aa_seq(codons)
print(aa_seq)
```

### **Function 5:** `aa_count()`

Amino acid sequences contain valuable information about protein structure. The `aa_count` function helps visualize the composition of these sequences.

#### Installation

Make sure to have the `stringr` and `ggplot2` packages installed. If not, you can install them using:

`install.packages("stringr")`

`install.packages("ggplot2")`

#### Usage

`aa_count(seq)`

##### Arguments

-   `seq`: a character **string** containing the amino acid sequence.

##### Return

-   A `ggplot` bar plot showing the absolute frequencies for each amino acid present in the given sequence.

```{r}
# Provide an amino acid sequence
seq1 <- "AKLPYNILSDFHVNSTRLGE"
# Call the function 
aa_plot <- aa_count(seq1)
```

### Discussion

#### Use Cases for `biodogma`

The `biodogma` package is useful in:

-   **Education**: This package helps students and educators simulate the processes of transcription and translation, visualizing how DNA is converted to RNA and then to proteins.

-   **Bioinformatics Research**: Researchers can use the package for quick simulations, such as generating synthetic DNA/RNA sequences, analyzing codon usage, and visualizing amino acid compositions in protein sequences, which can help in understanding protein structure, function, and enrichment of specific amino acids.

#### Potential Additional Functions

To enhance the packageâ€™s capabilities, the following functions could be added:

-   **Reverse Transcription**: A function to convert RNA back into DNA.

-   **Codon Optimization**: A function that suggests codon sequences based on species-specific codon usage bias.

-   **Protein Properties**: Functions to calculate protein properties such as molecular weight, hydrophobicity, or charge, which could assist in protein characterization and function prediction.

#### Dependencies

Although it is usually better to avoid dependencies, in this package we have used functions from `stringr` and `ggplot2` packages, due to their improved functionality and great usage. The avoidance of dependencies simplifies the complexity of the maintenance of packages as new changes in other packages may affect the functionality of another. Furthermore, it increases the usage as it does not need additional packages besides the one you are installing. However, this is not always possible as packages like those integrating the tidyverse implement complex function in an efficient manner.

We have used `@importFrom package function` tags in the function description because it reduces the repetition of the `package::function` form, however the latter does not add it to the namespace and reduces the dependencies as it only loads the used functions (although this can also be achieved by using `min_version = TRUE`).
